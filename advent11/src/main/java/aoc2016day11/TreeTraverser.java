package aoc2016day11;

/*
 * Copyright (C) 2012 The Guava Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


        import static aoc2016day11.Args.checkNotNull;

        import java.util.BitSet;
        import java.util.Collections;
        import java.util.Optional;
        import java.util.function.Function;
        import java.util.ArrayDeque;
        import java.util.Deque;
        import java.util.Iterator;
        import java.util.Queue;
        import java.util.stream.Stream;
        import java.util.stream.StreamSupport;

/**
 * Views elements of a type {@code T} as nodes in a tree, and provides methods to traverse the trees
 * induced by this traverser.
 *
 * <p>For example, the tree
 *
 * <pre>{@code
 *        h
 *      / | \
 *     /  e  \
 *    d       g
 *   /|\      |
 *  / | \     f
 * a  b  c
 * }</pre>
 *
 * <p>can be iterated over in preorder (hdabcegf), postorder (abcdefgh), or breadth-first order
 * (hdegabcf).
 *
 * <p>Null nodes are strictly forbidden.
 *
 * <p><b>For Java 8 users:</b> Because this is an abstract class, not an interface, you can't use a
 * lambda expression to extend it:
 *
 * <pre>{@code
 * // won't work
 * TreeTraverser<NodeType> traverser = node -> node.getChildNodes();
 * }</pre>
 *
 * Instead, you can pass a lambda expression to the {@code using} factory method:
 *
 * <pre>{@code
 * TreeTraverser<NodeType> traverser = TreeTraverser.using(node -> node.getChildNodes());
 * }</pre>
 *
 * @author Louis Wasserman
 * @since 15.0
 */
public abstract class TreeTraverser<T> {

    /**
     * Returns a tree traverser that uses the given function to navigate from a node to its children.
     * This is useful if the function instance already exists, or so that you can supply a lambda
     * expressions. If those circumstances don't apply, you probably don't need to use this; subclass
     * {@code TreeTraverser} and implement its {@link #children} method directly.
     *
     * @since 20.0
     */
    public static <T> TreeTraverser<T> using(
            final Function<T, ? extends Stream<T>> nodeToChildrenFunction) {
        checkNotNull(nodeToChildrenFunction);
        return new TreeTraverser<T>() {
            @Override
            public Stream<T> children(T root) {
                return nodeToChildrenFunction.apply(root);
            }
        };
    }

    /**
     * Returns the children of the specified node.  Must not contain null.
     */
    public abstract Stream<T> children(T root);

    /**
     * Returns an unmodifiable iterable over the nodes in a tree structure, using pre-order
     * traversal. That is, each node's subtrees are traversed after the node itself is returned.
     *
     * <p>No guarantees are made about the behavior of the traversal when nodes change while
     * iteration is in progress or when the iterators generated by {@link #children} are advanced.
     */
    public final Iterator<T> preOrderTraversal(final T root) {
        checkNotNull(root);
        return preOrderIterator(root);
    }

    // overridden in BinaryTreeTraverser
    Iterator<T> preOrderIterator(T root) {
        return new PreOrderIterator(root);
    }

    private final class PreOrderIterator implements Iterator<T> {
        private final Deque<Iterator<T>> stack;

        PreOrderIterator(T root) {
            this.stack = new ArrayDeque<>();
            stack.addLast(Collections.singletonList(checkNotNull(root)).iterator());
        }

        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }

        @Override
        public T next() {
            Iterator<T> itr = stack.getLast(); // throws NSEE if empty
            T result = checkNotNull(itr.next());
            if (!itr.hasNext()) {
                stack.removeLast();
            }
            Iterator<T> childItr = children(result).iterator();
            if (childItr.hasNext()) {
                stack.addLast(childItr);
            }
            return result;
        }
    }

    /**
     * Returns an unmodifiable iterable over the nodes in a tree structure, using post-order
     * traversal. That is, each node's subtrees are traversed before the node itself is returned.
     *
     * <p>No guarantees are made about the behavior of the traversal when nodes change while
     * iteration is in progress or when the iterators generated by {@link #children} are advanced.
     */
    public final Iterator<T> postOrderTraversal(final T root) {
        checkNotNull(root);
        return postOrderIterator(root);
    }

    // overridden in BinaryTreeTraverser
    protected Iterator<T> postOrderIterator(T root) {
        return new PostOrderIterator(root);
    }

    private static final class PostOrderNode<T> {
        final T root;
        final Iterator<T> childIterator;

        PostOrderNode(T root, Iterator<T> childIterator) {
            this.root = checkNotNull(root);
            this.childIterator = checkNotNull(childIterator);
        }
    }

    private final class PostOrderIterator extends AbstractIterator<T> {
        private final ArrayDeque<PostOrderNode<T>> stack;

        PostOrderIterator(T root) {
            this.stack = new ArrayDeque<>();
            stack.addLast(expand(root));
        }

        @Override
        protected T computeNext() {
            while (!stack.isEmpty()) {
                PostOrderNode<T> top = stack.getLast();
                if (top.childIterator.hasNext()) {
                    T child = top.childIterator.next();
                    stack.addLast(expand(child));
                } else {
                    stack.removeLast();
                    return top.root;
                }
            }
            return endOfData();
        }

        private PostOrderNode<T> expand(T t) {
            return new PostOrderNode<>(t, children(t).iterator());
        }
    }

    /**
     * Returns an unmodifiable iterable over the nodes in a tree structure, using breadth-first
     * traversal. That is, all the nodes of depth 0 are returned, then depth 1, then 2, and so on.
     *
     * <p>No guarantees are made about the behavior of the traversal when nodes change while
     * iteration is in progress or when the iterators generated by {@link #children} are advanced.
     */
    public final Iterator<T> breadthFirstTraversal(final T root) {
        checkNotNull(root);
        return new BreadthFirstIterator(root);
    }

    private final class BreadthFirstIterator implements PeekingIterator<T> {
        private final Queue<T> queue;

        BreadthFirstIterator(T root) {
            this.queue = new ArrayDeque<T>();
            queue.add(root);
        }

        @Override
        public boolean hasNext() {
            return !queue.isEmpty();
        }

        @Override
        public T peek() {
            return queue.element();
        }

        @Override
        public T next() {
            T result = queue.remove();
            children(result).forEach(queue::add);
            return result;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException("not supported");
        }
    }

    interface PeekingIterator<E> extends Iterator<E> {
        /**
         * Returns the next element in the iteration, without advancing the iteration.
         *
         * <p>Calls to {@code peek()} should not change the state of the iteration,
         * except that it <i>may</i> prevent removal of the most recent element via
         * {@link #remove()}.
         *
         * @throws NoSuchElementException if the iteration has no more elements
         *     according to {@link #hasNext()}
         */
        E peek();

        /**
         * {@inheritDoc}
         *
         * <p>The objects returned by consecutive calls to {@link #peek()} then {@link
         * #next()} are guaranteed to be equal to each other.
         */
        @Override
        E next();

        /**
         * {@inheritDoc}
         *
         * <p>Implementations may or may not support removal when a call to {@link
         * #peek()} has occurred since the most recent call to {@link #next()}.
         *
         * @throws IllegalStateException if there has been a call to {@link #peek()}
         *     since the most recent call to {@link #next()} and this implementation
         *     does not support this sequence of calls (optional)
         */
        @Override
        void remove();
    }

    static abstract class AbstractIterator<T> implements Iterator<T> {
        private State state = State.NOT_READY;

        /** Constructor for use by subclasses. */
        protected AbstractIterator() {}

        private enum State {
            /** We have computed the next element and haven't returned it yet. */
            READY,

            /** We haven't yet computed or have already returned the element. */
            NOT_READY,

            /** We have reached the end of the data and are finished. */
            DONE,

            /** We've suffered an exception and are kaput. */
            FAILED,
        }

        private T next;

        /**
         * Returns the next element. <b>Note:</b> the implementation must call {@link
         * #endOfData()} when there are no elements left in the iteration. Failure to
         * do so could result in an infinite loop.
         *
         * <p>The initial invocation of {@link #hasNext()} or {@link #next()} calls
         * this method, as does the first invocation of {@code hasNext} or {@code
         * next} following each successful call to {@code next}. Once the
         * implementation either invokes {@code endOfData} or throws an exception,
         * {@code computeNext} is guaranteed to never be called again.
         *
         * <p>If this method throws an exception, it will propagate outward to the
         * {@code hasNext} or {@code next} invocation that invoked this method. Any
         * further attempts to use the iterator will result in an {@link
         * IllegalStateException}.
         *
         * <p>The implementation of this method may not invoke the {@code hasNext},
         * {@code next}, or {@link #peek()} methods on this instance; if it does, an
         * {@code IllegalStateException} will result.
         *
         * @return the next element if there was one. If {@code endOfData} was called
         *     during execution, the return value will be ignored.
         * @throws RuntimeException if any unrecoverable error happens. This exception
         *     will propagate outward to the {@code hasNext()}, {@code next()}, or
         *     {@code peek()} invocation that invoked this method. Any further
         *     attempts to use the iterator will result in an
         *     {@link IllegalStateException}.
         */
        protected abstract T computeNext();

        /**
         * Implementations of {@link #computeNext} <b>must</b> invoke this method when
         * there are no elements left in the iteration.
         *
         * @return {@code null}; a convenience so your {@code computeNext}
         *     implementation can use the simple statement {@code return endOfData();}
         */
        protected final T endOfData() {
            state = State.DONE;
            return null;
        }

        @Override
        public final boolean hasNext() {
            Args.checkState(state != State.FAILED);
            switch (state) {
                case DONE:
                    return false;
                case READY:
                    return true;
                default:
            }
            return tryToComputeNext();
        }

        private boolean tryToComputeNext() {
            state = State.FAILED; // temporary pessimism
            next = computeNext();
            if (state != State.DONE) {
                state = State.READY;
                return true;
            }
            return false;
        }

        // TODO(kak): Should we remove this?
        @Override
        public final T next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            state = State.NOT_READY;
            T result = next;
            next = null;
            return result;
        }

        /**
         * Returns the next element in the iteration without advancing the iteration,
         * according to the contract of {@link PeekingIterator#peek()}.
         *
         * <p>Implementations of {@code AbstractIterator} that wish to expose this
         * functionality should implement {@code PeekingIterator}.
         */
        public final T peek() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            return next;
        }
    }
}

abstract class BinaryTreeTraverser<T> extends TreeTraverser<T> {

    /**
     * Returns the left child of the specified node, or {@link Optional#absent()} if the specified
     * node has no left child.
     */
    public abstract Optional<T> leftChild(T root);

    /**
     * Returns the right child of the specified node, or {@link Optional#absent()} if the specified
     * node has no right child.
     */
    public abstract Optional<T> rightChild(T root);

    private static <E> Stream<E> asStream(final Iterator<E> iterator) {
        Iterable<E> iterable = () -> iterator;
        Stream<E> stream = StreamSupport.stream(iterable.spliterator(), false);
        return stream;
    }

    /**
     * Returns the children of this node, in left-to-right order.
     */
    @Override
    public final Stream<T> children(final T root) {
        checkNotNull(root);
        return asStream(new AbstractIterator<T>() {
            boolean doneLeft;
            boolean doneRight;

            @Override
            protected T computeNext() {
                if (!doneLeft) {
                    doneLeft = true;
                    Optional<T> left = leftChild(root);
                    if (left.isPresent()) {
                        return left.get();
                    }
                }
                if (!doneRight) {
                    doneRight = true;
                    Optional<T> right = rightChild(root);
                    if (right.isPresent()) {
                        return right.get();
                    }
                }
                return endOfData();
            }
        });
    }

    @Override
    Iterator<T> preOrderIterator(T root) {
        return new PreOrderIterator(root);
    }

    /*
     * Optimized implementation of preOrderIterator for binary trees.
     */
    private final class PreOrderIterator implements PeekingIterator<T> {
        private final Deque<T> stack;

        PreOrderIterator(T root) {
            this.stack = new ArrayDeque<T>(8);
            stack.addLast(root);
        }

        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }

        @Override
        public T next() {
            T result = stack.removeLast();
            pushIfPresent(stack, rightChild(result));
            pushIfPresent(stack, leftChild(result));
            return result;
        }

        @Override
        public T peek() {
            return stack.getLast();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException("remove");
        }
    }

    @Override
    public Iterator<T> postOrderIterator(T root) {
        return new PostOrderIterator(root);
    }

    /*
     * Optimized implementation of postOrderIterator for binary trees.
     */
    private final class PostOrderIterator implements Iterator<T> {
        private final Deque<T> stack;
        private final BitSet hasExpanded;

        PostOrderIterator(T root) {
            this.stack = new ArrayDeque<T>(8);
            stack.addLast(root);
            this.hasExpanded = new BitSet();
        }

        @Override
        public boolean hasNext() {
            return !stack.isEmpty();
        }

        @Override
        public T next() {
            while (true) {
                T node = stack.getLast();
                boolean expandedNode = hasExpanded.get(stack.size() - 1);
                if (expandedNode) {
                    stack.removeLast();
                    hasExpanded.clear(stack.size());
                    return node;
                } else {
                    hasExpanded.set(stack.size() - 1);
                    pushIfPresent(stack, rightChild(node));
                    pushIfPresent(stack, leftChild(node));
                }
            }
        }
    }

    // TODO(lowasser): see if any significant optimizations are possible for breadthFirstIterator

    public final Iterator<T> inOrderTraversal(final T root) {
        checkNotNull(root);
        return new InOrderIterator(root);
    }

    private final class InOrderIterator extends AbstractIterator<T> {
        private final Deque<T> stack;
        private final BitSet hasExpandedLeft;

        InOrderIterator(T root) {
            this.stack = new ArrayDeque<T>(8);
            this.hasExpandedLeft = new BitSet();
            stack.addLast(root);
        }

        @Override
        protected T computeNext() {
            while (!stack.isEmpty()) {
                T node = stack.getLast();
                if (hasExpandedLeft.get(stack.size() - 1)) {
                    stack.removeLast();
                    hasExpandedLeft.clear(stack.size());
                    pushIfPresent(stack, rightChild(node));
                    return node;
                } else {
                    hasExpandedLeft.set(stack.size() - 1);
                    pushIfPresent(stack, leftChild(node));
                }
            }
            return endOfData();
        }
    }

    private static <T> void pushIfPresent(Deque<T> stack, Optional<T> node) {
        node.ifPresent(stack::addLast);
    }
}